{"ast":null,"code":"var _jsxFileName = \"/home/ankit/solana/dapp-scaffold/src/contexts/connection.tsx\";\nimport { useLocalStorageState } from \"./../utils/utils\";\nimport { Account, clusterApiUrl, Connection, PublicKey, Transaction } from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport { notify } from \"./../utils/notifications\";\nimport { ExplorerLink } from \"../components/ExplorerLink\";\nimport { setProgramIds } from \"../utils/ids\";\nimport { cache, getMultipleAccounts, MintParser } from \"./accounts\";\nimport { TokenListProvider, ENV as ChainID } from \"@solana/spl-token-registry\";\nexport const ENDPOINTS = [{\n  name: \"mainnet-beta\",\n  endpoint: \"https://solana-api.projectserum.com/\",\n  chainID: ChainID.MainnetBeta\n}, {\n  name: \"testnet\",\n  endpoint: clusterApiUrl(\"testnet\"),\n  chainID: ChainID.Testnet\n}, {\n  name: \"devnet\",\n  endpoint: clusterApiUrl(\"devnet\"),\n  chainID: ChainID.Devnet\n}, {\n  name: \"localnet\",\n  endpoint: \"http://127.0.0.1:8899\",\n  chainID: ChainID.Devnet\n}];\nconst DEFAULT = ENDPOINTS[0].endpoint;\nconst DEFAULT_SLIPPAGE = 0.25;\nconst ConnectionContext = React.createContext({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  slippage: DEFAULT_SLIPPAGE,\n  setSlippage: val => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  sendConnection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map()\n});\nexport function ConnectionProvider({\n  children = undefined\n}) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\"connectionEndpts\", ENDPOINTS[0].endpoint);\n  const [slippage, setSlippage] = useLocalStorageState(\"slippage\", DEFAULT_SLIPPAGE.toString());\n  const connection = useMemo(() => new Connection(endpoint, \"recent\"), [endpoint]);\n  const sendConnection = useMemo(() => new Connection(endpoint, \"recent\"), [endpoint]);\n  const chain = ENDPOINTS.find(end => end.endpoint === endpoint) || ENDPOINTS[0];\n  const env = chain.name;\n  const [tokens, setTokens] = useState([]);\n  const [tokenMap, setTokenMap] = useState(new Map());\n  useEffect(() => {\n    cache.clear(); // fetch token files\n\n    (async () => {\n      const res = await new TokenListProvider().resolve();\n      const list = res.filterByChainId(chain.chainID).excludeByTag(\"nft\").getList();\n      const knownMints = list.reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map());\n      const accounts = await getMultipleAccounts(connection, [...knownMints.keys()], 'single');\n      accounts.keys.forEach((key, index) => {\n        const account = accounts.array[index];\n\n        if (!account) {\n          return;\n        }\n\n        cache.add(new PublicKey(key), account, MintParser);\n      });\n      setTokenMap(knownMints);\n      setTokens(list);\n    })();\n  }, [connection, chain]);\n  setProgramIds(env); // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n\n  useEffect(() => {\n    const id = connection.onAccountChange(new Account().publicKey, () => {});\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n  useEffect(() => {\n    const id = sendConnection.onAccountChange(new Account().publicKey, () => {});\n    return () => {\n      sendConnection.removeAccountChangeListener(id);\n    };\n  }, [sendConnection]);\n  useEffect(() => {\n    const id = sendConnection.onSlotChange(() => null);\n    return () => {\n      sendConnection.removeSlotChangeListener(id);\n    };\n  }, [sendConnection]);\n  return /*#__PURE__*/React.createElement(ConnectionContext.Provider, {\n    value: {\n      endpoint,\n      setEndpoint,\n      slippage: parseFloat(slippage),\n      setSlippage: val => setSlippage(val.toString()),\n      connection,\n      sendConnection,\n      tokens,\n      tokenMap,\n      env\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 164,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function useConnection() {\n  return useContext(ConnectionContext).connection;\n}\nexport function useSendConnection() {\n  var _useContext;\n\n  return (_useContext = useContext(ConnectionContext)) === null || _useContext === void 0 ? void 0 : _useContext.sendConnection;\n}\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap\n  };\n}\nexport function useSlippageConfig() {\n  const {\n    slippage,\n    setSlippage\n  } = useContext(ConnectionContext);\n  return {\n    slippage,\n    setSlippage\n  };\n}\n\nconst getErrorForTransaction = async (connection, txid) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n  const errors = [];\n\n  if ((tx === null || tx === void 0 ? void 0 : tx.meta) && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport const sendTransaction = async (connection, wallet, instructions, signers, awaitConfirmation = true) => {\n  if (!(wallet === null || wallet === void 0 ? void 0 : wallet.publicKey)) {\n    throw new Error(\"Wallet is not connected\");\n  }\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (await connection.getRecentBlockhash(\"max\")).blockhash;\n  transaction.setSigners( // fee payied by the wallet owner\n  wallet.publicKey, ...signers.map(s => s.publicKey));\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  transaction = await wallet.signTransaction(transaction);\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment: \"singleGossip\"\n  };\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n\n  if (awaitConfirmation) {\n    const status = (await connection.confirmTransaction(txid, options && options.commitment)).value;\n\n    if (status === null || status === void 0 ? void 0 : status.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n      notify({\n        message: \"Transaction failed...\",\n        description: /*#__PURE__*/React.createElement(React.Fragment, null, errors.map(err => /*#__PURE__*/React.createElement(\"div\", {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 281,\n            columnNumber: 15\n          }\n        }, err)), /*#__PURE__*/React.createElement(ExplorerLink, {\n          address: txid,\n          type: \"transaction\",\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 283,\n            columnNumber: 13\n          }\n        })),\n        type: \"error\"\n      });\n      throw new Error(`Raw transaction ${txid} failed (${JSON.stringify(status)})`);\n    }\n  }\n\n  return txid;\n};","map":{"version":3,"sources":["/home/ankit/solana/dapp-scaffold/src/contexts/connection.tsx"],"names":["useLocalStorageState","Account","clusterApiUrl","Connection","PublicKey","Transaction","React","useContext","useEffect","useMemo","useState","notify","ExplorerLink","setProgramIds","cache","getMultipleAccounts","MintParser","TokenListProvider","ENV","ChainID","ENDPOINTS","name","endpoint","chainID","MainnetBeta","Testnet","Devnet","DEFAULT","DEFAULT_SLIPPAGE","ConnectionContext","createContext","setEndpoint","slippage","setSlippage","val","connection","sendConnection","env","tokens","tokenMap","Map","ConnectionProvider","children","undefined","toString","chain","find","end","setTokens","setTokenMap","clear","res","resolve","list","filterByChainId","excludeByTag","getList","knownMints","reduce","map","item","set","address","accounts","keys","forEach","key","index","account","array","add","id","onAccountChange","publicKey","removeAccountChangeListener","onSlotChange","removeSlotChangeListener","parseFloat","useConnection","useSendConnection","useConnectionConfig","context","useSlippageConfig","getErrorForTransaction","txid","confirmTransaction","tx","getParsedConfirmedTransaction","errors","meta","logMessages","log","regex","m","exec","lastIndex","length","push","sendTransaction","wallet","instructions","signers","awaitConfirmation","Error","transaction","instruction","recentBlockhash","getRecentBlockhash","blockhash","setSigners","s","partialSign","signTransaction","rawTransaction","serialize","options","skipPreflight","commitment","sendRawTransaction","status","value","err","message","description","type","JSON","stringify"],"mappings":"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","sourcesContent":["import { useLocalStorageState } from \"./../utils/utils\";\nimport {\n  Account,\n  clusterApiUrl,\n  Connection,\n  PublicKey,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport { notify } from \"./../utils/notifications\";\nimport { ExplorerLink } from \"../components/ExplorerLink\";\nimport { setProgramIds } from \"../utils/ids\";\nimport { WalletAdapter } from \"./wallet\";\nimport { cache, getMultipleAccounts, MintParser } from \"./accounts\";\nimport { TokenListProvider, ENV as ChainID, TokenInfo } from \"@solana/spl-token-registry\";\n\nexport type ENV =\n  | \"mainnet-beta\"\n  | \"testnet\"\n  | \"devnet\"\n  | \"localnet\";\n\nexport const ENDPOINTS = [\n  {\n    name: \"mainnet-beta\" as ENV,\n    endpoint: \"https://solana-api.projectserum.com/\",\n    chainID: ChainID.MainnetBeta,\n  },\n  {\n    name: \"testnet\" as ENV,\n    endpoint: clusterApiUrl(\"testnet\"),\n    chainID: ChainID.Testnet,\n  },\n  {\n    name: \"devnet\" as ENV,\n    endpoint: clusterApiUrl(\"devnet\"),\n    chainID: ChainID.Devnet,\n  },\n  {\n    name: \"localnet\" as ENV,\n    endpoint: \"http://127.0.0.1:8899\",\n    chainID: ChainID.Devnet,\n  },\n];\n\nconst DEFAULT = ENDPOINTS[0].endpoint;\nconst DEFAULT_SLIPPAGE = 0.25;\n\ninterface ConnectionConfig {\n  connection: Connection;\n  sendConnection: Connection;\n  endpoint: string;\n  slippage: number;\n  setSlippage: (val: number) => void;\n  env: ENV;\n  setEndpoint: (val: string) => void;\n  tokens: TokenInfo[];\n  tokenMap: Map<string, TokenInfo>;\n}\n\nconst ConnectionContext = React.createContext<ConnectionConfig>({\n  endpoint: DEFAULT,\n  setEndpoint: () => {},\n  slippage: DEFAULT_SLIPPAGE,\n  setSlippage: (val: number) => {},\n  connection: new Connection(DEFAULT, \"recent\"),\n  sendConnection: new Connection(DEFAULT, \"recent\"),\n  env: ENDPOINTS[0].name,\n  tokens: [],\n  tokenMap: new Map<string, TokenInfo>(),\n});\n\nexport function ConnectionProvider({ children = undefined as any }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    \"connectionEndpts\",\n    ENDPOINTS[0].endpoint\n  );\n\n  const [slippage, setSlippage] = useLocalStorageState(\n    \"slippage\",\n    DEFAULT_SLIPPAGE.toString()\n  );\n\n  const connection = useMemo(() => new Connection(endpoint, \"recent\"), [\n    endpoint,\n  ]);\n  const sendConnection = useMemo(() => new Connection(endpoint, \"recent\"), [\n    endpoint,\n  ]);\n\n  const chain =\n    ENDPOINTS.find((end) => end.endpoint === endpoint) || ENDPOINTS[0];\n  const env = chain.name;\n\n  const [tokens, setTokens] = useState<TokenInfo[]>([]);\n  const [tokenMap, setTokenMap] = useState<Map<string, TokenInfo>>(new Map());\n  useEffect(() => {\n    cache.clear();\n    // fetch token files\n    (async () => {\n      const res = await new TokenListProvider().resolve();\n      const list = res\n        .filterByChainId(chain.chainID)\n        .excludeByTag(\"nft\")\n        .getList();\n      const knownMints = list.reduce((map, item) => {\n        map.set(item.address, item);\n        return map;\n      }, new Map<string, TokenInfo>());\n\n      const accounts = await getMultipleAccounts(connection, [...knownMints.keys()], 'single');\n      accounts.keys.forEach((key, index) => {\n        const account = accounts.array[index];\n        if(!account) {\n          return;\n        }\n\n        cache.add(new PublicKey(key), account, MintParser);\n      })\n\n      setTokenMap(knownMints);\n      setTokens(list);\n    })();\n  }, [connection, chain]);\n\n  setProgramIds(env);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(new Account().publicKey, () => {});\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = sendConnection.onAccountChange(\n      new Account().publicKey,\n      () => {}\n    );\n    return () => {\n      sendConnection.removeAccountChangeListener(id);\n    };\n  }, [sendConnection]);\n\n  useEffect(() => {\n    const id = sendConnection.onSlotChange(() => null);\n    return () => {\n      sendConnection.removeSlotChangeListener(id);\n    };\n  }, [sendConnection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        slippage: parseFloat(slippage),\n        setSlippage: (val) => setSlippage(val.toString()),\n        connection,\n        sendConnection,\n        tokens,\n        tokenMap,\n        env,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  return useContext(ConnectionContext).connection as Connection;\n}\n\nexport function useSendConnection() {\n  return useContext(ConnectionContext)?.sendConnection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint,\n    env: context.env,\n    tokens: context.tokens,\n    tokenMap: context.tokenMap,\n  };\n}\n\nexport function useSlippageConfig() {\n  const { slippage, setSlippage } = useContext(ConnectionContext);\n  return { slippage, setSlippage };\n}\n\nconst getErrorForTransaction = async (connection: Connection, txid: string) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, \"max\");\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach((log) => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: WalletAdapter,\n  instructions: TransactionInstruction[],\n  signers: Account[],\n  awaitConfirmation = true\n) => {\n  if (!wallet?.publicKey) {\n    throw new Error(\"Wallet is not connected\");\n  }\n\n  let transaction = new Transaction();\n  instructions.forEach((instruction) => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    await connection.getRecentBlockhash(\"max\")\n  ).blockhash;\n  transaction.setSigners(\n    // fee payied by the wallet owner\n    wallet.publicKey,\n    ...signers.map((s) => s.publicKey)\n  );\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  transaction = await wallet.signTransaction(transaction);\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment: \"singleGossip\",\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n\n  if (awaitConfirmation) {\n    const status = (\n      await connection.confirmTransaction(\n        txid,\n        options && (options.commitment as any)\n      )\n    ).value;\n\n    if (status?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n      notify({\n        message: \"Transaction failed...\",\n        description: (\n          <>\n            {errors.map((err) => (\n              <div>{err}</div>\n            ))}\n            <ExplorerLink address={txid} type=\"transaction\" />\n          </>\n        ),\n        type: \"error\",\n      });\n\n      throw new Error(\n        `Raw transaction ${txid} failed (${JSON.stringify(status)})`\n      );\n    }\n  }\n\n  return txid;\n};\n"]},"metadata":{},"sourceType":"module"}