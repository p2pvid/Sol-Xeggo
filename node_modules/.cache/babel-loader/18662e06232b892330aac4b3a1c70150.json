{"ast":null,"code":"var _jsxFileName = \"/home/ankit/solana/dapp-scaffold/src/contexts/accounts.tsx\";\nimport React, { useCallback, useContext, useEffect, useState } from \"react\";\nimport { useConnection } from \"./connection\";\nimport { useWallet } from \"./wallet\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { AccountLayout, u64, MintLayout } from \"@solana/spl-token\";\nimport { chunks } from \"./../utils/utils\";\nimport { EventEmitter } from \"./../utils/eventEmitter\";\nimport { useUserAccounts } from \"../hooks/useUserAccounts\";\nimport { WRAPPED_SOL_MINT, programIds } from \"../utils/ids\";\nconst AccountsContext = React.createContext(null);\nconst pendingCalls = new Map();\nconst genericCache = new Map();\nconst transactionCache = new Map();\nexport const MintParser = (pubKey, info) => {\n  const buffer = Buffer.from(info.data);\n  const data = deserializeMint(buffer);\n  const details = {\n    pubkey: pubKey,\n    account: { ...info\n    },\n    info: data\n  };\n  return details;\n};\nexport const TokenAccountParser = (pubKey, info) => {\n  const buffer = Buffer.from(info.data);\n  const data = deserializeAccount(buffer);\n  const details = {\n    pubkey: pubKey,\n    account: { ...info\n    },\n    info: data\n  };\n  return details;\n};\nexport const GenericAccountParser = (pubKey, info) => {\n  const buffer = Buffer.from(info.data);\n  const details = {\n    pubkey: pubKey,\n    account: { ...info\n    },\n    info: buffer\n  };\n  return details;\n};\nexport const keyToAccountParser = new Map();\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (connection, pubKey, parser) => {\n    let id;\n\n    if (typeof pubKey === \"string\") {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let account = genericCache.get(address);\n\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n\n    if (query) {\n      return query;\n    } // TODO: refactor to use multiple accounts query with flush like behavior\n\n\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error(\"Account not found\");\n      }\n\n      return cache.add(id, data, parser);\n    });\n    pendingCalls.set(address, query);\n    return query;\n  },\n  add: (id, obj, parser) => {\n    if (obj.data.length === 0) {\n      return;\n    }\n\n    const address = typeof id === \"string\" ? id : id === null || id === void 0 ? void 0 : id.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n\n    if (!deserialize) {\n      throw new Error(\"Deserializer needs to be registered or passed as a parameter\");\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(new PublicKey(address), obj);\n\n    if (!account) {\n      return;\n    }\n\n    const isNew = !genericCache.has(address);\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize);\n    return account;\n  },\n  get: pubKey => {\n    let key;\n\n    if (typeof pubKey !== \"string\") {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: pubKey => {\n    let key;\n\n    if (typeof pubKey !== \"string\") {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n\n    return false;\n  },\n  byParser: parser => {\n    const result = [];\n\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey, parser) => {\n    if (pubkey) {\n      const address = typeof pubkey === \"string\" ? pubkey : pubkey === null || pubkey === void 0 ? void 0 : pubkey.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  addTransaction: (signature, tx) => {\n    transactionCache.set(signature, tx);\n    return tx;\n  },\n  addBulkTransactions: txs => {\n    for (const tx of txs) {\n      transactionCache.set(tx.signature.signature, tx);\n    }\n\n    return txs;\n  },\n  getTransaction: signature => {\n    const transaction = transactionCache.get(signature);\n    return transaction;\n  },\n  getAllTransactions: () => {\n    return transactionCache;\n  },\n  clear: () => {\n    genericCache.clear();\n    transactionCache.clear();\n    cache.emitter.raiseCacheCleared();\n  }\n};\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n  return context;\n};\n\nfunction wrapNativeAccount(pubkey, account) {\n  if (!account) {\n    return undefined;\n  }\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: pubkey,\n      mint: WRAPPED_SOL_MINT,\n      owner: pubkey,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null\n    }\n  };\n}\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const {\n    wallet,\n    publicKey\n  } = useWallet();\n  const [nativeAccount, setNativeAccount] = useState();\n  const updateCache = useCallback(account => {\n    if (!connection || !publicKey) {\n      return;\n    }\n\n    const wrapped = wrapNativeAccount(publicKey, account);\n\n    if (wrapped !== undefined) {\n      const id = publicKey.toBase58();\n      cache.registerParser(id, TokenAccountParser);\n      genericCache.set(id, wrapped);\n      cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser);\n    }\n  }, [publicKey, connection]);\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      return;\n    }\n\n    connection.getAccountInfo(publicKey).then(acc => {\n      if (acc) {\n        updateCache(acc);\n        setNativeAccount(acc);\n      }\n    });\n    connection.onAccountChange(publicKey, acc => {\n      if (acc) {\n        updateCache(acc);\n        setNativeAccount(acc);\n      }\n    });\n  }, [setNativeAccount, wallet, publicKey, connection, updateCache]);\n  return {\n    nativeAccount\n  };\n};\n\nconst PRECACHED_OWNERS = new Set();\n\nconst precacheUserTokenAccounts = async (connection, owner) => {\n  if (!owner) {\n    return;\n  } // used for filtering account updates over websocket\n\n\n  PRECACHED_OWNERS.add(owner.toBase58()); // user accounts are update via ws subscription\n\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token\n  });\n  accounts.value.forEach(info => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({\n  children = null\n}) {\n  const connection = useConnection();\n  const {\n    publicKey,\n    wallet,\n    connected\n  } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState([]);\n  const [userAccounts, setUserAccounts] = useState([]);\n  const {\n    nativeAccount\n  } = UseNativeAccount();\n  const selectUserAccounts = useCallback(() => {\n    if (!publicKey) {\n      return [];\n    }\n\n    const address = publicKey.toBase58();\n    return cache.byParser(TokenAccountParser).map(id => cache.get(id)).filter(a => a && a.info.owner.toBase58() === address).map(a => a);\n  }, [publicKey]);\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(a => a !== undefined);\n    setUserAccounts(accounts);\n  }, [nativeAccount, wallet, tokenAccounts, selectUserAccounts]);\n  useEffect(() => {\n    const subs = [];\n    cache.emitter.onCache(args => {\n      if (args.isNew) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), info => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n    return () => {\n      subs.forEach(id => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      }); // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n\n      const tokenSubID = connection.onProgramAccountChange(programIds().token, info => {\n        // TODO: fix type in web3.js\n        const id = info.accountId; // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n\n        if (info.accountInfo.data.length === AccountLayout.span) {\n          const data = deserializeAccount(info.accountInfo.data);\n\n          if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n            cache.add(id, info.accountInfo, TokenAccountParser);\n            setTokenAccounts(selectUserAccounts());\n          }\n        }\n      }, \"singleGossip\");\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, connected, publicKey, selectUserAccounts]);\n  return /*#__PURE__*/React.createElement(AccountsContext.Provider, {\n    value: {\n      userAccounts,\n      nativeAccount\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 414,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount\n  };\n}\nexport const getMultipleAccounts = async (connection, keys, commitment) => {\n  const result = await Promise.all(chunks(keys, 99).map(chunk => getMultipleAccountsCore(connection, chunk, commitment)));\n  const array = result.map(a => a.array.map(acc => {\n    if (!acc) {\n      return undefined;\n    }\n\n    const {\n      data,\n      ...rest\n    } = acc;\n    const obj = { ...rest,\n      data: Buffer.from(data[0], \"base64\")\n    };\n    return obj;\n  }).filter(_ => _)).flat();\n  return {\n    keys,\n    array\n  };\n};\n\nconst getMultipleAccountsCore = async (connection, keys, commitment) => {\n  const args = connection._buildArgs([keys], commitment, \"base64\");\n\n  const unsafeRes = await connection._rpcRequest(\"getMultipleAccounts\", args);\n\n  if (unsafeRes.error) {\n    throw new Error(\"failed to get info about account \" + unsafeRes.error.message);\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value;\n    return {\n      keys,\n      array\n    };\n  } // TODO: fix\n\n\n  throw new Error();\n};\n\nexport function useMint(key) {\n  const connection = useConnection();\n  const [mint, setMint] = useState();\n  const id = typeof key === \"string\" ? key : key === null || key === void 0 ? void 0 : key.toBase58();\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache.query(connection, id, MintParser).then(acc => setMint(acc.info)).catch(err => console.log(err));\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n\n      if (event.id === id) {\n        cache.query(connection, id, MintParser).then(mint => setMint(mint.info));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n  return mint;\n}\nexport const useAccountByMint = mint => {\n  const {\n    userAccounts\n  } = useUserAccounts();\n  const index = userAccounts.findIndex(acc => acc.info.mint.toBase58() === mint);\n\n  if (index !== -1) {\n    return userAccounts[index];\n  }\n\n  return;\n};\nexport function useAccount(pubKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState();\n  const key = pubKey === null || pubKey === void 0 ? void 0 : pubKey.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache.query(connection, key, TokenAccountParser).catch(err => console.log(err));\n\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n    const dispose = cache.emitter.onCache(e => {\n      const event = e;\n\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n  return account;\n} // TODO: expose in spl package\n\nconst deserializeAccount = data => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n}; // TODO: expose in spl package\n\n\nconst deserializeMint = data => {\n  if (data.length !== MintLayout.span) {\n    throw new Error(\"Not a valid Mint\");\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo;\n};","map":{"version":3,"sources":["/home/ankit/solana/dapp-scaffold/src/contexts/accounts.tsx"],"names":["React","useCallback","useContext","useEffect","useState","useConnection","useWallet","PublicKey","AccountLayout","u64","MintLayout","chunks","EventEmitter","useUserAccounts","WRAPPED_SOL_MINT","programIds","AccountsContext","createContext","pendingCalls","Map","genericCache","transactionCache","MintParser","pubKey","info","buffer","Buffer","from","data","deserializeMint","details","pubkey","account","TokenAccountParser","deserializeAccount","GenericAccountParser","keyToAccountParser","cache","emitter","query","connection","parser","id","address","toBase58","get","getAccountInfo","then","Error","add","set","obj","length","deserialize","registerParser","delete","isNew","has","raiseCacheUpdated","key","raiseCacheDeleted","byParser","result","keys","push","addTransaction","signature","tx","addBulkTransactions","txs","getTransaction","transaction","getAllTransactions","clear","raiseCacheCleared","useAccountsContext","context","wrapNativeAccount","undefined","mint","owner","amount","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","UseNativeAccount","wallet","publicKey","nativeAccount","setNativeAccount","updateCache","wrapped","acc","onAccountChange","PRECACHED_OWNERS","Set","precacheUserTokenAccounts","accounts","getTokenAccountsByOwner","programId","token","value","forEach","AccountsProvider","children","connected","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","selectUserAccounts","map","filter","a","subs","onCache","args","removeAccountChangeListener","tokenSubID","onProgramAccountChange","accountId","accountInfo","span","removeProgramAccountChangeListener","useNativeAccount","getMultipleAccounts","commitment","Promise","all","chunk","getMultipleAccountsCore","array","rest","_","flat","_buildArgs","unsafeRes","_rpcRequest","error","message","useMint","setMint","catch","err","console","log","dispose","e","event","useAccountByMint","index","findIndex","useAccount","setAccount","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority"],"mappings":"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","sourcesContent":["import React, { useCallback, useContext, useEffect, useState } from \"react\";\nimport { useConnection } from \"./connection\";\nimport { useWallet } from \"./wallet\";\nimport {\n  AccountInfo,\n  ConfirmedSignatureInfo,\n  ConfirmedTransaction,\n  Connection,\n  PublicKey,\n} from \"@solana/web3.js\";\nimport { AccountLayout, u64, MintInfo, MintLayout } from \"@solana/spl-token\";\nimport { TokenAccount } from \"./../models\";\nimport { chunks } from \"./../utils/utils\";\nimport { EventEmitter } from \"./../utils/eventEmitter\";\nimport { useUserAccounts } from \"../hooks/useUserAccounts\";\nimport { WRAPPED_SOL_MINT, programIds } from \"../utils/ids\";\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\nconst transactionCache = new Map<string, ParsedLocalTransaction | null>();\n\nexport interface ParsedLocalTransaction {\n  transactionType: number;\n  signature: ConfirmedSignatureInfo;\n  confirmedTx: ConfirmedTransaction | null;\n}\n\nexport interface ParsedAccountBase {\n  pubkey: PublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unkown\n}\n\nexport type AccountParser = (\n  pubkey: PublicKey,\n  data: AccountInfo<Buffer>\n) => ParsedAccountBase | undefined;\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nexport const MintParser = (pubKey: PublicKey, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = (\n  pubKey: PublicKey,\n  info: AccountInfo<Buffer>\n) => {\n  const buffer = Buffer.from(info.data);\n  const data = deserializeAccount(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as TokenAccount;\n\n  return details;\n};\n\nexport const GenericAccountParser = (\n  pubKey: PublicKey,\n  info: AccountInfo<Buffer>\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  emitter: new EventEmitter(),\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === \"string\") {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    // TODO: refactor to use multiple accounts query with flush like behavior\n    query = connection.getAccountInfo(id).then((data) => {\n      if (!data) {\n        throw new Error(\"Account not found\");\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (\n    id: PublicKey | string,\n    obj: AccountInfo<Buffer>,\n    parser?: AccountParser\n  ) => {\n    if (obj.data.length === 0) {\n      return;\n    }\n\n    const address = typeof id === \"string\" ? id : id?.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        \"Deserializer needs to be registered or passed as a parameter\"\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(new PublicKey(address), obj);\n    if (!account) {\n      return;\n    }\n\n    const isNew = !genericCache.has(address);\n\n    genericCache.set(address, account);\n    cache.emitter.raiseCacheUpdated(address, isNew, deserialize);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== \"string\") {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  delete: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== \"string\") {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (genericCache.get(key)) {\n      genericCache.delete(key);\n      cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n    return false;\n  },\n\n  byParser: (parser: AccountParser) => {\n    const result: string[] = [];\n    for (const id of keyToAccountParser.keys()) {\n      if (keyToAccountParser.get(id) === parser) {\n        result.push(id);\n      }\n    }\n\n    return result;\n  },\n  registerParser: (pubkey: PublicKey | string, parser: AccountParser) => {\n    if (pubkey) {\n      const address = typeof pubkey === \"string\" ? pubkey : pubkey?.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  addTransaction: (signature: string, tx: ParsedLocalTransaction | null) => {\n    transactionCache.set(signature, tx);\n    return tx;\n  },\n  addBulkTransactions: (txs: Array<ParsedLocalTransaction>) => {\n    for (const tx of txs) {\n      transactionCache.set(tx.signature.signature, tx);\n    }\n    return txs;\n  },\n  getTransaction: (signature: string) => {\n    const transaction = transactionCache.get(signature);\n    return transaction;\n  },\n  getAllTransactions: () => {\n    return transactionCache;\n  },\n  clear: () => {\n    genericCache.clear();\n    transactionCache.clear();\n    cache.emitter.raiseCacheCleared();\n  },\n};\n\nexport const useAccountsContext = () => {\n  const context = useContext(AccountsContext);\n\n  return context;\n};\n\nfunction wrapNativeAccount(\n  pubkey: PublicKey,\n  account?: AccountInfo<Buffer>\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      address: pubkey,\n      mint: WRAPPED_SOL_MINT,\n      owner: pubkey,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { wallet, publicKey } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n\n  const updateCache = useCallback(\n    (account) => {\n      if (!connection || !publicKey) {\n        return;\n      }\n\n      const wrapped = wrapNativeAccount(publicKey, account);\n      if (wrapped !== undefined) {\n        const id = publicKey.toBase58();\n        cache.registerParser(id, TokenAccountParser);\n        genericCache.set(id, wrapped as TokenAccount);\n        cache.emitter.raiseCacheUpdated(id, false, TokenAccountParser);\n      }\n    },\n    [publicKey, connection]\n  );\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      return;\n    }\n\n    connection.getAccountInfo(publicKey).then((acc) => {\n      if (acc) {\n        updateCache(acc);\n        setNativeAccount(acc);\n      }\n    });\n    connection.onAccountChange(publicKey, (acc) => {\n      if (acc) {\n        updateCache(acc);\n        setNativeAccount(acc);\n      }\n    });\n  }, [setNativeAccount, wallet, publicKey, connection, updateCache]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are update via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n  accounts.value.forEach((info) => {\n    cache.add(info.pubkey.toBase58(), info.account, TokenAccountParser);\n  });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { publicKey, wallet, connected } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n\n  const selectUserAccounts = useCallback(() => {\n    if (!publicKey) {\n      return [];\n    }\n\n    const address = publicKey.toBase58();\n\n    return cache\n      .byParser(TokenAccountParser)\n      .map((id) => cache.get(id))\n      .filter((a) => a && a.info.owner.toBase58() === address)\n      .map((a) => a as TokenAccount);\n  }, [publicKey]);\n\n  useEffect(() => {\n    const accounts = selectUserAccounts().filter(\n      (a) => a !== undefined\n    ) as TokenAccount[];\n    setUserAccounts(accounts);\n  }, [nativeAccount, wallet, tokenAccounts, selectUserAccounts]);\n\n  useEffect(() => {\n    const subs: number[] = [];\n    cache.emitter.onCache((args) => {\n      if (args.isNew) {\n        let id = args.id;\n        let deserialize = args.parser;\n        connection.onAccountChange(new PublicKey(id), (info) => {\n          cache.add(id, info, deserialize);\n        });\n      }\n    });\n\n    return () => {\n      subs.forEach((id) => connection.removeAccountChangeListener(id));\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        (info) => {\n          // TODO: fix type in web3.js\n          const id = (info.accountId as unknown) as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n\n            if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n              cache.add(id, info.accountInfo, TokenAccountParser);\n              setTokenAccounts(selectUserAccounts());\n            }\n          }\n        },\n        \"singleGossip\"\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, connected, publicKey, selectUserAccounts]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map((chunk) =>\n      getMultipleAccountsCore(connection, chunk, commitment)\n    )\n  );\n\n  const array = result\n    .map(\n      (a) =>\n        a.array\n          .map((acc) => {\n            if (!acc) {\n              return undefined;\n            }\n\n            const { data, ...rest } = acc;\n            const obj = {\n              ...rest,\n              data: Buffer.from(data[0], \"base64\"),\n            } as AccountInfo<Buffer>;\n            return obj;\n          })\n          .filter((_) => _) as AccountInfo<Buffer>[]\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string\n) => {\n  const args = connection._buildArgs([keys], commitment, \"base64\");\n\n  const unsafeRes = await connection._rpcRequest(\"getMultipleAccounts\", args);\n  if (unsafeRes.error) {\n    throw new Error(\n      \"failed to get info about account \" + unsafeRes.error.message\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(key?: string | PublicKey) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  const id = typeof key === \"string\" ? key : key?.toBase58();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .query(connection, id, MintParser)\n      .then((acc) => setMint(acc.info as any))\n      .catch((err) => console.log(err));\n\n    const dispose = cache.emitter.onCache((e) => {\n      const event = e;\n      if (event.id === id) {\n        cache\n          .query(connection, id, MintParser)\n          .then((mint) => setMint(mint.info as any));\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport const useAccountByMint = (mint: string) => {\n  const { userAccounts } = useUserAccounts();\n  const index = userAccounts.findIndex(\n    (acc) => acc.info.mint.toBase58() === mint\n  );\n\n  if (index !== -1) {\n    return userAccounts[index];\n  }\n\n  return;\n};\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache\n          .query(connection, key, TokenAccountParser)\n          .catch((err) => console.log(err));\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = cache.emitter.onCache((e) => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\n// TODO: expose in spl package\nconst deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nconst deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error(\"Not a valid Mint\");\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n"]},"metadata":{},"sourceType":"module"}