{"ast":null,"code":"var _jsxFileName = \"/home/ankit/solana/dapp-scaffold/src/contexts/market.tsx\";\nimport React, { useCallback, useContext, useEffect, useState } from \"react\";\nimport { MINT_TO_MARKET } from \"./../models/marketOverrides\";\nimport { STABLE_COINS } from \"./../utils/utils\";\nimport { useConnectionConfig } from \"./connection\";\nimport { cache, getMultipleAccounts } from \"./accounts\";\nimport { Market, MARKETS, Orderbook, TOKEN_MINTS } from \"@project-serum/serum\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport { useMemo } from \"react\";\nimport { EventEmitter } from \"./../utils/eventEmitter\";\nimport { DexMarketParser } from \"./../models/dex\";\nimport { useUserAccounts } from \"../hooks\";\nexport const BONFIDA_POOL_INTERVAL = 30 * 60000; // 30 min\n\nconst REFRESH_INTERVAL = 30000;\nconst MarketsContext = React.createContext(null);\nconst marketEmitter = new EventEmitter();\nexport function MarketProvider({\n  children = null\n}) {\n  const {\n    endpoint\n  } = useConnectionConfig();\n  const accountsToObserve = useMemo(() => new Map(), []);\n  const [marketMints, setMarketMints] = useState([]);\n  const {\n    userAccounts\n  } = useUserAccounts();\n  const connection = useMemo(() => new Connection(endpoint, \"recent\"), [endpoint]);\n  const marketByMint = useMemo(() => {\n    return [...new Set(marketMints).values()].reduce((acc, key) => {\n      const mintAddress = key;\n      const SERUM_TOKEN = TOKEN_MINTS.find(a => a.address.toBase58() === mintAddress);\n      const marketAddress = MINT_TO_MARKET[mintAddress];\n      const marketInfo = MARKETS.filter(m => !m.deprecated).find(m => m.name === `${SERUM_TOKEN === null || SERUM_TOKEN === void 0 ? void 0 : SERUM_TOKEN.name}/USDC` || m.name === `${SERUM_TOKEN === null || SERUM_TOKEN === void 0 ? void 0 : SERUM_TOKEN.name}/USDT` || m.address.toBase58() === marketAddress);\n\n      if (marketInfo) {\n        acc.set(mintAddress, {\n          marketInfo\n        });\n      }\n\n      return acc;\n    }, new Map());\n  }, [marketMints]);\n  useEffect(() => {\n    let timer = 0;\n\n    const updateData = async () => {\n      await refreshAccounts(connection, [...accountsToObserve.keys()]);\n      marketEmitter.raiseMarketUpdated(new Set([...marketByMint.keys()]));\n      timer = window.setTimeout(() => updateData(), REFRESH_INTERVAL);\n    };\n\n    const initalQuery = async () => {\n      const reverseSerumMarketCache = new Map();\n      [...marketByMint.keys()].forEach(mint => {\n        const m = marketByMint.get(mint);\n\n        if (m) {\n          reverseSerumMarketCache.set(m.marketInfo.address.toBase58(), mint);\n        }\n      });\n      const allMarkets = [...marketByMint.values()].map(m => {\n        return m.marketInfo.address.toBase58();\n      });\n      await getMultipleAccounts(connection, // only query for markets that are not in cahce\n      allMarkets.filter(a => cache.get(a) === undefined), \"single\").then(({\n        keys,\n        array\n      }) => {\n        allMarkets.forEach(() => {});\n        return array.map((item, index) => {\n          const marketAddress = keys[index];\n          const mintAddress = reverseSerumMarketCache.get(marketAddress);\n\n          if (mintAddress) {\n            const market = marketByMint.get(mintAddress);\n\n            if (market) {\n              const id = market.marketInfo.address;\n              cache.add(id, item, DexMarketParser);\n            }\n          }\n\n          return item;\n        });\n      });\n      const toQuery = new Set();\n      allMarkets.forEach(m => {\n        const market = cache.get(m);\n\n        if (!market) {\n          return;\n        }\n\n        const decoded = market;\n\n        if (!cache.get(decoded.info.baseMint)) {\n          toQuery.add(decoded.info.baseMint.toBase58());\n        }\n\n        if (!cache.get(decoded.info.baseMint)) {\n          toQuery.add(decoded.info.quoteMint.toBase58());\n        }\n\n        toQuery.add(decoded.info.bids.toBase58());\n        toQuery.add(decoded.info.asks.toBase58());\n      });\n      await refreshAccounts(connection, [...toQuery.keys()]);\n      marketEmitter.raiseMarketUpdated(new Set([...marketByMint.keys()])); // start update loop\n\n      updateData();\n    };\n\n    initalQuery();\n    return () => {\n      window.clearTimeout(timer);\n    };\n  }, [marketByMint, accountsToObserve, connection]);\n  const midPriceInUSD = useCallback(mintAddress => {\n    var _marketByMint$get;\n\n    return getMidPrice((_marketByMint$get = marketByMint.get(mintAddress)) === null || _marketByMint$get === void 0 ? void 0 : _marketByMint$get.marketInfo.address.toBase58(), mintAddress);\n  }, [marketByMint]);\n  const subscribeToMarket = useCallback(mintAddress => {\n    const info = marketByMint.get(mintAddress);\n    const market = cache.get((info === null || info === void 0 ? void 0 : info.marketInfo.address.toBase58()) || \"\");\n\n    if (!market) {\n      return () => {};\n    } // TODO: get recent volume\n\n\n    const bid = market.info.bids.toBase58();\n    const ask = market.info.asks.toBase58();\n    accountsToObserve.set(bid, (accountsToObserve.get(bid) || 0) + 1);\n    accountsToObserve.set(ask, (accountsToObserve.get(ask) || 0) + 1); // TODO: add event queue to query for last trade\n\n    return () => {\n      accountsToObserve.set(bid, (accountsToObserve.get(bid) || 0) - 1);\n      accountsToObserve.set(ask, (accountsToObserve.get(ask) || 0) - 1); // cleanup\n\n      [...accountsToObserve.keys()].forEach(key => {\n        if ((accountsToObserve.get(key) || 0) <= 0) {\n          accountsToObserve.delete(key);\n        }\n      });\n    };\n  }, [marketByMint, accountsToObserve]);\n  const precacheMarkets = useCallback(mints => {\n    const newMints = [...new Set([...marketMints, ...mints]).values()];\n\n    if (marketMints.length !== newMints.length) {\n      setMarketMints(newMints);\n    }\n  }, [setMarketMints, marketMints]);\n  useEffect(() => {\n    precacheMarkets(userAccounts.map(a => a.info.mint.toBase58()));\n  }, [userAccounts, precacheMarkets]);\n  return /*#__PURE__*/React.createElement(MarketsContext.Provider, {\n    value: {\n      midPriceInUSD,\n      marketEmitter,\n      accountsToObserve,\n      marketByMint,\n      subscribeToMarket,\n      precacheMarkets\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport const useMarkets = () => {\n  const context = useContext(MarketsContext);\n  return context;\n};\nexport const useMidPriceInUSD = mint => {\n  const {\n    midPriceInUSD,\n    subscribeToMarket,\n    marketEmitter\n  } = useContext(MarketsContext);\n  const [price, setPrice] = useState(0);\n  useEffect(() => {\n    let subscription = subscribeToMarket(mint);\n\n    const update = () => {\n      if (midPriceInUSD) {\n        setPrice(midPriceInUSD(mint));\n      }\n    };\n\n    update();\n    const dispose = marketEmitter.onMarket(update);\n    return () => {\n      subscription();\n      dispose();\n    };\n  }, [midPriceInUSD, mint, marketEmitter, subscribeToMarket]);\n  return {\n    price,\n    isBase: price === 1.0\n  };\n};\nexport const usePrecacheMarket = () => {\n  const context = useMarkets();\n  return context.precacheMarkets;\n};\n\nconst bbo = (bidsBook, asksBook) => {\n  const bestBid = bidsBook.getL2(1);\n  const bestAsk = asksBook.getL2(1);\n\n  if (bestBid.length > 0 && bestAsk.length > 0) {\n    return (bestBid[0][0] + bestAsk[0][0]) / 2.0;\n  }\n\n  return 0;\n};\n\nconst getMidPrice = (marketAddress, mintAddress) => {\n  var _cache$get, _cache$get2, _cache$get3, _cache$get4;\n\n  const SERUM_TOKEN = TOKEN_MINTS.find(a => a.address.toBase58() === mintAddress);\n\n  if (STABLE_COINS.has((SERUM_TOKEN === null || SERUM_TOKEN === void 0 ? void 0 : SERUM_TOKEN.name) || \"\")) {\n    return 1.0;\n  }\n\n  if (!marketAddress) {\n    return 0.0;\n  }\n\n  const marketInfo = cache.get(marketAddress);\n\n  if (!marketInfo) {\n    return 0.0;\n  }\n\n  const decodedMarket = marketInfo.info;\n  const baseMintDecimals = ((_cache$get = cache.get(decodedMarket.baseMint)) === null || _cache$get === void 0 ? void 0 : _cache$get.info.decimals) || 0;\n  const quoteMintDecimals = ((_cache$get2 = cache.get(decodedMarket.quoteMint)) === null || _cache$get2 === void 0 ? void 0 : _cache$get2.info.decimals) || 0;\n  const market = new Market(decodedMarket, baseMintDecimals, quoteMintDecimals, undefined, decodedMarket.programId);\n  const bids = (_cache$get3 = cache.get(decodedMarket.bids)) === null || _cache$get3 === void 0 ? void 0 : _cache$get3.info;\n  const asks = (_cache$get4 = cache.get(decodedMarket.asks)) === null || _cache$get4 === void 0 ? void 0 : _cache$get4.info;\n\n  if (bids && asks) {\n    const bidsBook = new Orderbook(market, bids.accountFlags, bids.slab);\n    const asksBook = new Orderbook(market, asks.accountFlags, asks.slab);\n    return bbo(bidsBook, asksBook);\n  }\n\n  return 0;\n};\n\nconst refreshAccounts = async (connection, keys) => {\n  if (keys.length === 0) {\n    return [];\n  }\n\n  return getMultipleAccounts(connection, keys, \"single\").then(({\n    keys,\n    array\n  }) => {\n    return array.map((item, index) => {\n      const address = keys[index];\n      return cache.add(new PublicKey(address), item);\n    });\n  });\n};","map":{"version":3,"sources":["/home/ankit/solana/dapp-scaffold/src/contexts/market.tsx"],"names":["React","useCallback","useContext","useEffect","useState","MINT_TO_MARKET","STABLE_COINS","useConnectionConfig","cache","getMultipleAccounts","Market","MARKETS","Orderbook","TOKEN_MINTS","Connection","PublicKey","useMemo","EventEmitter","DexMarketParser","useUserAccounts","BONFIDA_POOL_INTERVAL","REFRESH_INTERVAL","MarketsContext","createContext","marketEmitter","MarketProvider","children","endpoint","accountsToObserve","Map","marketMints","setMarketMints","userAccounts","connection","marketByMint","Set","values","reduce","acc","key","mintAddress","SERUM_TOKEN","find","a","address","toBase58","marketAddress","marketInfo","filter","m","deprecated","name","set","timer","updateData","refreshAccounts","keys","raiseMarketUpdated","window","setTimeout","initalQuery","reverseSerumMarketCache","forEach","mint","get","allMarkets","map","undefined","then","array","item","index","market","id","add","toQuery","decoded","info","baseMint","quoteMint","bids","asks","clearTimeout","midPriceInUSD","getMidPrice","subscribeToMarket","bid","ask","delete","precacheMarkets","mints","newMints","length","useMarkets","context","useMidPriceInUSD","price","setPrice","subscription","update","dispose","onMarket","isBase","usePrecacheMarket","bbo","bidsBook","asksBook","bestBid","getL2","bestAsk","has","decodedMarket","baseMintDecimals","decimals","quoteMintDecimals","programId","accountFlags","slab"],"mappings":"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","sourcesContent":["import React, { useCallback, useContext, useEffect, useState } from \"react\";\nimport { MINT_TO_MARKET } from \"./../models/marketOverrides\";\nimport { STABLE_COINS } from \"./../utils/utils\";\nimport { useConnectionConfig } from \"./connection\";\nimport { cache, getMultipleAccounts } from \"./accounts\";\nimport { Market, MARKETS, Orderbook, TOKEN_MINTS } from \"@project-serum/serum\";\nimport { AccountInfo, Connection, PublicKey } from \"@solana/web3.js\";\nimport { useMemo } from \"react\";\nimport { EventEmitter } from \"./../utils/eventEmitter\";\n\nimport { DexMarketParser } from \"./../models/dex\";\nimport { useUserAccounts } from \"../hooks\";\n\nexport const BONFIDA_POOL_INTERVAL = 30 * 60_000; // 30 min\n\ninterface RecentPoolData {\n  pool_identifier: string;\n  volume24hA: number;\n}\n\nexport interface MarketsContextState {\n  midPriceInUSD: (mint: string) => number;\n  marketEmitter: EventEmitter;\n  accountsToObserve: Map<string, number>;\n  marketByMint: Map<string, SerumMarket>;\n\n  subscribeToMarket: (mint: string) => () => void;\n\n  precacheMarkets: (mints: string[]) => void;\n}\n\nconst REFRESH_INTERVAL = 30_000;\n\nconst MarketsContext = React.createContext<MarketsContextState | null>(null);\n\nconst marketEmitter = new EventEmitter();\n\nexport function MarketProvider({ children = null as any }) {\n  const { endpoint } = useConnectionConfig();\n  const accountsToObserve = useMemo(() => new Map<string, number>(), []);\n  const [marketMints, setMarketMints] = useState<string[]>([]);\n  const { userAccounts } = useUserAccounts();\n\n  const connection = useMemo(() => new Connection(endpoint, \"recent\"), [\n    endpoint,\n  ]);\n\n  const marketByMint = useMemo(() => {\n    return [...new Set(marketMints).values()].reduce((acc, key) => {\n      const mintAddress = key;\n\n      const SERUM_TOKEN = TOKEN_MINTS.find(\n        (a) => a.address.toBase58() === mintAddress\n      );\n\n      const marketAddress = MINT_TO_MARKET[mintAddress];\n      const marketInfo = MARKETS.filter(m => !m.deprecated).find(\n        (m) => m.name === `${SERUM_TOKEN?.name}/USDC` || \n               m.name === `${SERUM_TOKEN?.name}/USDT` || \n               m.address.toBase58() === marketAddress\n      );\n\n      if (marketInfo) {\n        acc.set(mintAddress, {\n          marketInfo,\n        });\n      }\n\n      return acc;\n    }, new Map<string, SerumMarket>()) as Map<string, SerumMarket>;\n  }, [marketMints]);\n\n  useEffect(() => {\n    let timer = 0;\n\n    const updateData = async () => {\n      await refreshAccounts(connection, [...accountsToObserve.keys()]);\n      marketEmitter.raiseMarketUpdated(new Set([...marketByMint.keys()]));\n\n      timer = window.setTimeout(() => updateData(), REFRESH_INTERVAL);\n    };\n\n    const initalQuery = async () => {\n      const reverseSerumMarketCache = new Map<string, string>();\n      [...marketByMint.keys()].forEach((mint) => {\n        const m = marketByMint.get(mint);\n        if (m) {\n          reverseSerumMarketCache.set(m.marketInfo.address.toBase58(), mint);\n        }\n      });\n\n      const allMarkets = [...marketByMint.values()].map((m) => {\n        return m.marketInfo.address.toBase58();\n      });\n\n      await getMultipleAccounts(\n        connection,\n        // only query for markets that are not in cahce\n        allMarkets.filter((a) => cache.get(a) === undefined),\n        \"single\"\n      ).then(({ keys, array }) => {\n        allMarkets.forEach(() => {});\n\n        return array.map((item, index) => {\n          const marketAddress = keys[index];\n          const mintAddress = reverseSerumMarketCache.get(marketAddress);\n          if (mintAddress) {\n            const market = marketByMint.get(mintAddress);\n\n            if (market) {\n              const id = market.marketInfo.address;\n              cache.add(id, item, DexMarketParser);\n            }\n          }\n\n          return item;\n        });\n      });\n\n      const toQuery = new Set<string>();\n      allMarkets.forEach((m) => {\n        const market = cache.get(m);\n        if (!market) {\n          return;\n        }\n\n        const decoded = market;\n\n        if (!cache.get(decoded.info.baseMint)) {\n          toQuery.add(decoded.info.baseMint.toBase58());\n        }\n\n        if (!cache.get(decoded.info.baseMint)) {\n          toQuery.add(decoded.info.quoteMint.toBase58());\n        }\n\n        toQuery.add(decoded.info.bids.toBase58());\n        toQuery.add(decoded.info.asks.toBase58());\n      });\n\n      await refreshAccounts(connection, [...toQuery.keys()]);\n\n      marketEmitter.raiseMarketUpdated(new Set([...marketByMint.keys()]));\n\n      // start update loop\n      updateData();\n    };\n\n    initalQuery();\n\n    return () => {\n      window.clearTimeout(timer);\n    };\n  }, [marketByMint, accountsToObserve, connection]);\n\n  const midPriceInUSD = useCallback(\n    (mintAddress: string) => {\n      return getMidPrice(\n        marketByMint.get(mintAddress)?.marketInfo.address.toBase58(),\n        mintAddress\n      );\n    },\n    [marketByMint]\n  );\n\n  const subscribeToMarket = useCallback(\n    (mintAddress: string) => {\n      const info = marketByMint.get(mintAddress);\n      const market = cache.get(info?.marketInfo.address.toBase58() || \"\");\n      if (!market) {\n        return () => {};\n      }\n\n      // TODO: get recent volume\n\n      const bid = market.info.bids.toBase58();\n      const ask = market.info.asks.toBase58();\n      accountsToObserve.set(bid, (accountsToObserve.get(bid) || 0) + 1);\n      accountsToObserve.set(ask, (accountsToObserve.get(ask) || 0) + 1);\n\n      // TODO: add event queue to query for last trade\n\n      return () => {\n        accountsToObserve.set(bid, (accountsToObserve.get(bid) || 0) - 1);\n        accountsToObserve.set(ask, (accountsToObserve.get(ask) || 0) - 1);\n\n        // cleanup\n        [...accountsToObserve.keys()].forEach((key) => {\n          if ((accountsToObserve.get(key) || 0) <= 0) {\n            accountsToObserve.delete(key);\n          }\n        });\n      };\n    },\n    [marketByMint, accountsToObserve]\n  );\n\n  const precacheMarkets = useCallback(\n    (mints: string[]) => {\n      const newMints = [...new Set([...marketMints, ...mints]).values()];\n\n      if (marketMints.length !== newMints.length) {\n        setMarketMints(newMints);\n      }\n    },\n    [setMarketMints, marketMints]\n  );\n\n  useEffect(() => {\n    precacheMarkets(userAccounts.map(a => a.info.mint.toBase58()));\n  }, [userAccounts, precacheMarkets]);\n\n  return (\n    <MarketsContext.Provider\n      value={{\n        midPriceInUSD,\n        marketEmitter,\n        accountsToObserve,\n        marketByMint,\n        subscribeToMarket,\n        precacheMarkets,\n      }}\n    >\n      {children}\n    </MarketsContext.Provider>\n  );\n}\n\nexport const useMarkets = () => {\n  const context = useContext(MarketsContext);\n  return context as MarketsContextState;\n};\n\nexport const useMidPriceInUSD = (mint: string) => {\n  const { midPriceInUSD, subscribeToMarket, marketEmitter } = useContext(\n    MarketsContext\n  ) as MarketsContextState;\n  const [price, setPrice] = useState<number>(0);\n\n  useEffect(() => {\n    let subscription = subscribeToMarket(mint);\n    const update = () => {\n      if (midPriceInUSD) {\n        setPrice(midPriceInUSD(mint));\n      }\n    };\n\n    update();\n    const dispose = marketEmitter.onMarket(update);\n\n    return () => {\n      subscription();\n      dispose();\n    };\n  }, [midPriceInUSD, mint, marketEmitter, subscribeToMarket]);\n\n  return { price, isBase: price === 1.0 };\n};\n\nexport const usePrecacheMarket = () => {\n  const context = useMarkets();\n  return context.precacheMarkets;\n};\n\nconst bbo = (bidsBook: Orderbook, asksBook: Orderbook) => {\n  const bestBid = bidsBook.getL2(1);\n  const bestAsk = asksBook.getL2(1);\n\n  if (bestBid.length > 0 && bestAsk.length > 0) {\n    return (bestBid[0][0] + bestAsk[0][0]) / 2.0;\n  }\n\n  return 0;\n};\n\nconst getMidPrice = (marketAddress?: string, mintAddress?: string) => {\n  const SERUM_TOKEN = TOKEN_MINTS.find(\n    (a) => a.address.toBase58() === mintAddress\n  );\n\n  if (STABLE_COINS.has(SERUM_TOKEN?.name || \"\")) {\n    return 1.0;\n  }\n\n  if (!marketAddress) {\n    return 0.0;\n  }\n\n  const marketInfo = cache.get(marketAddress);\n  if (!marketInfo) {\n    return 0.0;\n  }\n\n  const decodedMarket = marketInfo.info;\n\n  const baseMintDecimals =\n    cache.get(decodedMarket.baseMint)?.info.decimals || 0;\n  const quoteMintDecimals =\n    cache.get(decodedMarket.quoteMint)?.info.decimals || 0;\n\n  const market = new Market(\n    decodedMarket,\n    baseMintDecimals,\n    quoteMintDecimals,\n    undefined,\n    decodedMarket.programId\n  );\n\n  const bids = cache.get(decodedMarket.bids)?.info;\n  const asks = cache.get(decodedMarket.asks)?.info;\n\n  if (bids && asks) {\n    const bidsBook = new Orderbook(market, bids.accountFlags, bids.slab);\n    const asksBook = new Orderbook(market, asks.accountFlags, asks.slab);\n\n    return bbo(bidsBook, asksBook);\n  }\n\n  return 0;\n};\n\nconst refreshAccounts = async (connection: Connection, keys: string[]) => {\n  if (keys.length === 0) {\n    return [];\n  }\n\n  return getMultipleAccounts(connection, keys, \"single\").then(\n    ({ keys, array }) => {\n      return array.map((item, index) => {\n        const address = keys[index];\n        return cache.add(new PublicKey(address), item);\n      });\n    }\n  );\n};\n\ninterface SerumMarket {\n  marketInfo: {\n    address: PublicKey;\n    name: string;\n    programId: PublicKey;\n    deprecated: boolean;\n  };\n\n  // 1st query\n  marketAccount?: AccountInfo<Buffer>;\n\n  // 2nd query\n  mintBase?: AccountInfo<Buffer>;\n  mintQuote?: AccountInfo<Buffer>;\n  bidAccount?: AccountInfo<Buffer>;\n  askAccount?: AccountInfo<Buffer>;\n  eventQueue?: AccountInfo<Buffer>;\n\n  swap?: {\n    dailyVolume: number;\n  };\n\n  midPrice?: (mint?: PublicKey) => number;\n}\n"]},"metadata":{},"sourceType":"module"}