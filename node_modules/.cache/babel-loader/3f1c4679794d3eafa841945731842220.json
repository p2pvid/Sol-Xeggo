{"ast":null,"code":"import { useCallback, useState } from \"react\";\nimport BN from \"bn.js\";\nimport { WAD, ZERO } from \"../constants\";\nexport const formatPriceNumber = new Intl.NumberFormat(\"en-US\", {\n  style: \"decimal\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8\n});\nexport function useLocalStorageState(key, defaultState) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n\n    return defaultState;\n  });\n  const setLocalStorageState = useCallback(newState => {\n    const changed = state !== newState;\n\n    if (!changed) {\n      return;\n    }\n\n    setState(newState);\n\n    if (newState === null) {\n      localStorage.removeItem(key);\n    } else {\n      localStorage.setItem(key, JSON.stringify(newState));\n    }\n  }, [state, key]);\n  return [state, setLocalStorageState];\n} // shorten the checksummed version of the input address to have 4 characters at start and end\n\nexport function shortenAddress(address, chars = 4) {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\nexport function getTokenName(map, mint, shorten = true) {\n  var _map$get;\n\n  const mintAddress = typeof mint === \"string\" ? mint : mint === null || mint === void 0 ? void 0 : mint.toBase58();\n\n  if (!mintAddress) {\n    return \"N/A\";\n  }\n\n  const knownSymbol = (_map$get = map.get(mintAddress)) === null || _map$get === void 0 ? void 0 : _map$get.symbol;\n\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\nexport function getTokenByName(tokenMap, name) {\n  let token = null;\n\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n\n  return token;\n}\nexport function getTokenIcon(map, mintAddress) {\n  var _map$get2;\n\n  const address = typeof mintAddress === \"string\" ? mintAddress : mintAddress === null || mintAddress === void 0 ? void 0 : mintAddress.toBase58();\n\n  if (!address) {\n    return;\n  }\n\n  return (_map$get2 = map.get(address)) === null || _map$get2 === void 0 ? void 0 : _map$get2.logoURI;\n}\nexport function isKnownMint(map, mintAddress) {\n  return !!map.get(mintAddress);\n}\nexport const STABLE_COINS = new Set([\"USDC\", \"wUSDC\", \"USDT\"]);\nexport function chunks(array, size) {\n  return Array.apply(0, new Array(Math.ceil(array.length / size))).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\nexport function toLamports(account, mint) {\n  var _account$info$amount;\n\n  if (!account) {\n    return 0;\n  }\n\n  const amount = typeof account === \"number\" ? account : (_account$info$amount = account.info.amount) === null || _account$info$amount === void 0 ? void 0 : _account$info$amount.toNumber();\n  const precision = Math.pow(10, (mint === null || mint === void 0 ? void 0 : mint.decimals) || 0);\n  return Math.floor(amount * precision);\n}\nexport function wadToLamports(amount) {\n  return (amount === null || amount === void 0 ? void 0 : amount.div(WAD)) || ZERO;\n}\nexport function fromLamports(account, mint, rate = 1.0) {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(typeof account === \"number\" ? account : BN.isBN(account) ? account.toNumber() : account.info.amount.toNumber());\n  const precision = Math.pow(10, (mint === null || mint === void 0 ? void 0 : mint.decimals) || 0);\n  return amount / precision * rate;\n}\nvar SI_SYMBOL = [\"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\"];\n\nconst abbreviateNumber = (number, precision) => {\n  let tier = Math.log10(number) / 3 | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (val, precision = 6, abbr = true) => abbr ? abbreviateNumber(val, precision) : val.toFixed(precision);\nexport function formatTokenAmount(account, mint, rate = 1.0, prefix = \"\", suffix = \"\", precision = 6, abbr = false) {\n  if (!account) {\n    return \"\";\n  }\n\n  return `${[prefix]}${formatAmount(fromLamports(account, mint, rate), precision, abbr)}${suffix}`;\n}\nexport const formatUSD = new Intl.NumberFormat(\"en-US\", {\n  style: \"currency\",\n  currency: \"USD\"\n});\nexport const numberFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"decimal\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2\n});\nexport const isSmallNumber = val => {\n  return val < 0.001 && val > 0;\n};\nexport const formatNumber = {\n  format: (val, useSmall) => {\n    if (!val) {\n      return \"--\";\n    }\n\n    if (useSmall && isSmallNumber(val)) {\n      return 0.001;\n    }\n\n    return numberFormatter.format(val);\n  }\n};\nexport const feeFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"decimal\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 9\n});\nexport const formatPct = new Intl.NumberFormat(\"en-US\", {\n  style: \"percent\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2\n});\nexport function convert(account, mint, rate = 1.0) {\n  var _account$info$amount2;\n\n  if (!account) {\n    return 0;\n  }\n\n  const amount = typeof account === \"number\" ? account : (_account$info$amount2 = account.info.amount) === null || _account$info$amount2 === void 0 ? void 0 : _account$info$amount2.toNumber();\n  const precision = Math.pow(10, (mint === null || mint === void 0 ? void 0 : mint.decimals) || 0);\n  let result = amount / precision * rate;\n  return result;\n}","map":{"version":3,"sources":["/home/ankit/solana/dapp-scaffold/src/utils/utils.ts"],"names":["useCallback","useState","BN","WAD","ZERO","formatPriceNumber","Intl","NumberFormat","style","minimumFractionDigits","maximumFractionDigits","useLocalStorageState","key","defaultState","state","setState","storedState","localStorage","getItem","JSON","parse","setLocalStorageState","newState","changed","removeItem","setItem","stringify","shortenAddress","address","chars","slice","getTokenName","map","mint","shorten","mintAddress","toBase58","knownSymbol","get","symbol","substring","getTokenByName","tokenMap","name","token","val","values","getTokenIcon","logoURI","isKnownMint","STABLE_COINS","Set","chunks","array","size","Array","apply","Math","ceil","length","_","index","toLamports","account","amount","info","toNumber","precision","pow","decimals","floor","wadToLamports","div","fromLamports","rate","isBN","SI_SYMBOL","abbreviateNumber","number","tier","log10","scaled","suffix","scale","toFixed","formatAmount","abbr","formatTokenAmount","prefix","formatUSD","currency","numberFormatter","isSmallNumber","formatNumber","format","useSmall","feeFormatter","formatPct","convert","result"],"mappings":"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","sourcesContent":["import { useCallback, useState } from \"react\";\nimport { MintInfo } from \"@solana/spl-token\";\n\nimport { TokenAccount } from \"./../models\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\nimport { WAD, ZERO } from \"../constants\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\n\nexport type KnownTokenMap = Map<string, TokenInfo>;\n\nexport const formatPriceNumber = new Intl.NumberFormat(\"en-US\", {\n  style: \"decimal\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 8,\n});\n\nexport function useLocalStorageState(key: string, defaultState?: string) {\n  const [state, setState] = useState(() => {\n    // NOTE: Not sure if this is ok\n    const storedState = localStorage.getItem(key);\n    if (storedState) {\n      return JSON.parse(storedState);\n    }\n    return defaultState;\n  });\n\n  const setLocalStorageState = useCallback(\n    (newState) => {\n      const changed = state !== newState;\n      if (!changed) {\n        return;\n      }\n      setState(newState);\n      if (newState === null) {\n        localStorage.removeItem(key);\n      } else {\n        localStorage.setItem(key, JSON.stringify(newState));\n      }\n    },\n    [state, key]\n  );\n\n  return [state, setLocalStorageState];\n}\n\n// shorten the checksummed version of the input address to have 4 characters at start and end\nexport function shortenAddress(address: string, chars = 4): string {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\n\nexport function getTokenName(\n  map: KnownTokenMap,\n  mint?: string | PublicKey,\n  shorten = true\n): string {\n  const mintAddress = typeof mint === \"string\" ? mint : mint?.toBase58();\n\n  if (!mintAddress) {\n    return \"N/A\";\n  }\n\n  const knownSymbol = map.get(mintAddress)?.symbol;\n  if (knownSymbol) {\n    return knownSymbol;\n  }\n\n  return shorten ? `${mintAddress.substring(0, 5)}...` : mintAddress;\n}\n\nexport function getTokenByName(tokenMap: KnownTokenMap, name: string) {\n  let token: TokenInfo | null = null;\n  for (const val of tokenMap.values()) {\n    if (val.symbol === name) {\n      token = val;\n      break;\n    }\n  }\n  return token;\n}\n\nexport function getTokenIcon(\n  map: KnownTokenMap,\n  mintAddress?: string | PublicKey\n): string | undefined {\n  const address =\n    typeof mintAddress === \"string\" ? mintAddress : mintAddress?.toBase58();\n  if (!address) {\n    return;\n  }\n\n  return map.get(address)?.logoURI;\n}\n\nexport function isKnownMint(map: KnownTokenMap, mintAddress: string) {\n  return !!map.get(mintAddress);\n}\n\nexport const STABLE_COINS = new Set([\"USDC\", \"wUSDC\", \"USDT\"]);\n\nexport function chunks<T>(array: T[], size: number): T[][] {\n  return Array.apply<number, T[], T[][]>(\n    0,\n    new Array(Math.ceil(array.length / size))\n  ).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nexport function toLamports(\n  account?: TokenAccount | number,\n  mint?: MintInfo\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === \"number\" ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return Math.floor(amount * precision);\n}\n\nexport function wadToLamports(amount?: BN): BN {\n  return amount?.div(WAD) || ZERO;\n}\n\nexport function fromLamports(\n  account?: TokenAccount | number | BN,\n  mint?: MintInfo,\n  rate: number = 1.0\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount = Math.floor(\n    typeof account === \"number\"\n      ? account\n      : BN.isBN(account)\n      ? account.toNumber()\n      : account.info.amount.toNumber()\n  );\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  return (amount / precision) * rate;\n}\n\nvar SI_SYMBOL = [\"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\"];\n\nconst abbreviateNumber = (number: number, precision: number) => {\n  let tier = (Math.log10(number) / 3) | 0;\n  let scaled = number;\n  let suffix = SI_SYMBOL[tier];\n  if (tier !== 0) {\n    let scale = Math.pow(10, tier * 3);\n    scaled = number / scale;\n  }\n\n  return scaled.toFixed(precision) + suffix;\n};\n\nexport const formatAmount = (\n  val: number,\n  precision: number = 6,\n  abbr: boolean = true\n) => (abbr ? abbreviateNumber(val, precision) : val.toFixed(precision));\n\nexport function formatTokenAmount(\n  account?: TokenAccount,\n  mint?: MintInfo,\n  rate: number = 1.0,\n  prefix = \"\",\n  suffix = \"\",\n  precision = 6,\n  abbr = false\n): string {\n  if (!account) {\n    return \"\";\n  }\n\n  return `${[prefix]}${formatAmount(\n    fromLamports(account, mint, rate),\n    precision,\n    abbr\n  )}${suffix}`;\n}\n\nexport const formatUSD = new Intl.NumberFormat(\"en-US\", {\n  style: \"currency\",\n  currency: \"USD\",\n});\n\nexport const numberFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"decimal\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const isSmallNumber = (val: number) => {\n  return val < 0.001 && val > 0;\n};\n\nexport const formatNumber = {\n  format: (val?: number, useSmall?: boolean) => {\n    if (!val) {\n      return \"--\";\n    }\n    if (useSmall && isSmallNumber(val)) {\n      return 0.001;\n    }\n\n    return numberFormatter.format(val);\n  },\n};\n\nexport const feeFormatter = new Intl.NumberFormat(\"en-US\", {\n  style: \"decimal\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 9,\n});\n\nexport const formatPct = new Intl.NumberFormat(\"en-US\", {\n  style: \"percent\",\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport function convert(\n  account?: TokenAccount | number,\n  mint?: MintInfo,\n  rate: number = 1.0\n): number {\n  if (!account) {\n    return 0;\n  }\n\n  const amount =\n    typeof account === \"number\" ? account : account.info.amount?.toNumber();\n\n  const precision = Math.pow(10, mint?.decimals || 0);\n  let result = (amount / precision) * rate;\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}